<html>
<head><title>Embedding Fscript</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="style"/>
</head>
<body>
<center><h2>FScript</h2>
<i>by murlen</i>
</center>
<a href="page3.html">[Previous]</a>&nbsp;<a href="index.html">[Contents]</a>&nbsp;<a href="page5.html">[Next]</a><hr></hr>

<h2>Embedding Fscript</h2>


<a name="link0"></a><h4>Introduction</h4>

<p>
FScript is intended to be embedded within other applications.  
</p>

<p>This can be done in three (count them, three) ways:</p>

<ul>
<li>Subclassing FScript and <a href="#subc">overriding</a>
 a number of key methods</li>

<li>Implementing a separate <a href="#ext">extension</a>
 class and registering it with FScript</li>

<li>Using the <a href="#fast">FSFastExtension</a>
 class and registering (simpler) extensions with it</li>

</ul>

<p>The first method is the simplest, but the second provides much greater
flexibility, as it is possible to register multiple extensions simultaneously.</p>

<p>You will also need to know the various methods used to load code into FScript, and to 
execute it.</p>



<a name="link1"></a><h4>Subclassing FScript</h4>
<a name="subc"></a>

<p>This is done by simply sub-classing FScript class, and overriding a number of
 key methods.  This resulting class is then used to process the FScript scripts. </p>

<p>The BasicIO class can be examined to see how this is done.  The BasicIO class 
provides (very basic) IO capabilities to FScript.  If correctly implemented (see below)
such subclasses can themselves be subclassed to add further features.</p>

<p>Also see the JavaDoc for more detailed information.</p>

<p><b>Methods to Override</b>
</p>

<p>There are 3 functions that you may override to integrate FScript with your
application. These are:</p>

<ul>
<li>callFunction</li>

<li>setVar (and setVar with index)</li>

<li>getVar (and getVar with index)</li>

</ul>

<p><b>callFunction</b>
</p>

<p><i>callFunction</i>
 is called whenever a function call is encountered in the script
that has not been previously defined.  Hence allowing the application embedding FScript
to appear to have functions mapped into FScript's name space. It is called with two parameters, 
the first being the function name, and the second being an array list of parameters passed to the
function from the script.</p>

<p>Typically this Method will perform the actions associated with the passed in function
name, and perhaps return a value.  A returned value must be one of the FScript supported
types (String, Integer and Double).</p>

<p>If the function name does not match one your method is expecting, it is typically an error.  
The preferred method of handling this is to call <i>super.callFunction</i>
.  This makes it possible
to 'chain' subclasses of FScript together (e.g. you could subclass BasicIO, add one function, and
any calls you did not process would be handed back to BasicIO).  Although if you
are doing this you may want to look at <a href="#ext">extensions</a>
</p>
 which
could provide a simpler interface.
<p>The <i>callFunction</i>
 method can only throw a FSException, so all exceptions generated by
your code will need to be handled (if necessary by re-throwing as an FSException).  Any
thrown FSException will be caught, and additional context information added, before being 
re-thrown.</p>


<p><b>setVar/getVar</b>
</p>

<p>This method is called when a FScript variable name is encountered that has not
been previously defined - hence allowing the application embedding FScript to 
appear to have variables mapped into FScript's name space.</p>

<p><i>setVar</i>
 is called with two parameters one being the variable name, and 
the other being the value to which that 'variable' is to be set.  <i>getVar</i>
 is called
only with a variable name, and the method is expected to return one of the Java types
recognized by FScript (Integer, String and Double).</p>

<p>As with <i>callFunction</i>
 if the variable name passed in is not one the embedding 
application expects it should call <i>super.setVar / super.getVar </i>
.  Also like <i>callFunction</i>

only FSExceptions my be thrown by these methods.</p>

<p>Both <i>setVar</i>
 and <i>getVar</i>
 have versions that also accept index parameters, this
allows for array like access to variables defined in subclasses (see JavaDoc for 
details).</p>



<a name="link2"></a><h4>Using Extensions</h4>

<a name="ext"></a>

<p>A more flexible approach than subclassing is using extensions.  Any class wishing to register
as an extension to FScript must implement the <i>FSExtension</i>
 interface.  This methods defined
by this interface mirror the ones discussed above (<i>callFunction,getVar</i>
 and <i>setVar</i>
).
These methods will then be called when unknown variables or function names are encountered
in a script.</p>

<p>It is <b>vital</b>
 that if an extension receives a call for a function or variable name that
is not implemented by this extension it <b>must</b>
 raise a <i>FSUnsupportedExtension</i>
.
This enables the call to be passed on to other extensions.  The only other exception that may
be thrown is a <i>FSException</i>
 which is used to indicate an error condition.</p>

<p>In order to register an extension with FScript the method <i>registerExtension</i>
 is called.  To
remove an extension call <i>unRegisterExtension</i>
 (which may be important as FScript retains
a reference to the extension, so it will not be garbage collected).</p>

<p>The fragment of code below shows an example of extension use:</p>

<pre>
	FScript fs=new FScript();
	MyDataBaseExtension db=new MyDataBaseExtension();
	//register various extensions
	fs.registerExtension(db);
	fs.registerExtension(new MyIOExtension());
	fs.registerExtensoin(new MyWebExtension());

	fs.load(inputFileReader);

	rs.run();

	//just because we can
	fs.unRegisterExtension(db);
</pre>

<p>As the FScript class itself implements the FSExtension interface, any subclasses of FScript may
also be used as FScript extensions - although this is probably not all that efficient.</p>

<p>A class <i>BasicExtension</i>
 is provided that can be subclassed to simplify building extensions.,
It simply implements <i>FSExtension</i>
 and all method calls throw a 
<i>FSUnsupportedException.</i>
</p>



<a name="link3"></a><h4>Using FSFastExtension</h4>

<a name="fast"></a>

<p>
The <i>FSFastExtension</i>
 class provides a way of creating even simpler extensions to FScript (i.e they 
do not have to implement the whole <i>FSExtension</i>
 interface).  To use you register an instance of 
FSFastExtension with the FScript parser, and then add extensions to the <i>FSFastExtension</i>
 instance.
These extensions can implement <i>FSVarExtension</i>
, <i>FSFunctionExtension</i>
 or <i>FSArrayExtension</i>
,
where these classes define the relevant methods for handling variables, functions or array type variables.  
In fact the FSExtension interface is really just a compound of these three interfaces.
</p>

<p>
The coding needed for these <i>FSFastExtension</i>
 classes is similar to that for subclasses and 
extensions mentioned above.  See the examples directory for an example of <i>FSFastExtension</i>
 in use.
</p>




<hr></hr>
<a href="page3.html">[Previous]</a>&nbsp;<a href="index.html">[Contents]</a>&nbsp;<a href="page5.html">[Next]</a><br></br>
<i><font size="-2">created with DocLite</font>
</i>


</body>
</html>
